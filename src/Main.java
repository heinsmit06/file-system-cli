import exception.CommandArgsException;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Stream;

public class Main {

    private static String helpMessage = "MyFS 1.0 команды:\n" +
            "ls <path>               выводит список всех файлов и директорий для `path`\n" +
            "ls_py <path>            выводит список файлов с расширением `.py` в `path`\n" +
            "is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`\n" +
            "define <path>           выводит `директория` или `файл` в зависимости от типа `path`\n" +
            "readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя\n" +
            "setmod <path> <perm>    устанавливает права для файла `path`\n" +
            "cat <path>              выводит контент файла\n" +
            "append <path>           добавляет строку `# Autogenerated line` в конец `path`\n" +
            "bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`\n" +
            "greplong <path>         выводит самое длинное слово в файле\n" +
            "help                    выводит список команд и их описание\n" +
            "exit                    завершает работу программы";
    private static String GOODBYE_MSG = "Goodbye";
    private static String FOOTER = "# Autogenerated line";

    private static File[] getListOfFiles(String path) {
        File file = new File(path);
        return file.listFiles();
    }

    public static void help() {
        System.out.println(helpMessage);
    }

    public static void exit() {
        System.out.println(GOODBYE_MSG);
    }

    private static List<String> getArgs(String userInput) {
        String[] args = userInput.split(" ");
        return Arrays.stream(args).toList();
    }

    public static void listDirectory(String path) {
        File[] filesArr = getListOfFiles(path);
        if (filesArr == null) return;
        for (File currentFile: filesArr) {
            System.out.print(currentFile.getName() + " ");
        }
        System.out.print("\n");
    }

    private static String getEndOfFile(String filename) {
        if (filename.indexOf('.') == -1) return "";
        return filename.substring(filename.indexOf('.'));
    }

    public static void listPythonFiles(String path) {
        File[] filesArr = getListOfFiles(path);
        if (filesArr == null) return;
        for (File currentFile: filesArr) {
            if (getEndOfFile(currentFile.getName()).equals(".py")) {
                System.out.print(currentFile.getName() + " ");
            }
        }
        System.out.println();
    }

    public static void isDirectory(String path) throws FileNotFoundException {
        File file = new File(path);
        if (!file.exists()) {
            throw new FileNotFoundException("File not found at the path:" + path);
        }

        System.out.println(file.isDirectory());
    }

    public static void define(String path) throws FileNotFoundException {
        File file = new File(path);
        if (!file.exists()) {
            throw new FileNotFoundException("File not found at the path:" + path);
        }

        if (file.isDirectory()) {
            System.out.println("directory");
            return;
        } else if (file.isFile()) {
            System.out.println("file");
        }
    }

    public static void printPermissions(String path) throws FileNotFoundException {
        File file = new File(path);
        if (!file.exists()) {
            throw new FileNotFoundException("File not found at the path:" + path);
        }

        String permissions = "";
        permissions += (file.canRead()) ? "r" : "-";
        permissions += (file.canWrite()) ? "w" : "-";
        permissions += (file.canExecute()) ? "x" : "-";

        System.out.println(permissions);
    }

    public static void setPermissions(String path, String permissions) throws Exception {

        File file = new File(path);
        if (!file.exists()) {
            throw new FileNotFoundException("File not found at the path:" + path);
        }

        if (permissions == null || permissions.length() != 3) {
            throw new IllegalArgumentException("Permissions must be exactly 3 characters long");
        }

        boolean readable = (permissions.charAt(0) == 'r');
        boolean writable = (permissions.charAt(1) == 'w');
        boolean executable = (permissions.charAt(2) == 'x');
        file.setReadable(readable);
        file.setWritable(writable);
        file.setExecutable(executable);

    }

    public static void printContent(String path) throws FileNotFoundException {
        File file = new File(path);
        Scanner scanner = new Scanner(file);
        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }
        scanner.close();
    }

    public static void appendFooter(String path) throws IOException {
        File file = new File(path);
        FileWriter fw = new FileWriter(path, true);
        BufferedWriter bw = new BufferedWriter(fw);

        bw.write(FOOTER);
        bw.newLine();
        bw.close();
    }

    public static void printLongestWord(String path) throws FileNotFoundException {
        File file = new File(path);
        String longestWord = "";
        Scanner scanner = new Scanner(file);

        while (scanner.hasNextLine()) {
            String currentLine = scanner.nextLine();
            String[] wordsOfCurrentLine = currentLine.split(" ");
            for (int i = 0; i < wordsOfCurrentLine.length; i++) {
                if (wordsOfCurrentLine[i].length() > longestWord.length()) {
                    longestWord = wordsOfCurrentLine[i];
                }
            }
        }

        scanner.close();
        System.out.println(longestWord);
    }

    public static void createBackup(String path) throws IOException {
        File file = new File(path);
        String currentDate = new SimpleDateFormat("dd-mm-yyyy").format(new Date());

        Path filePath = Paths.get(path);
        Path bcPath = Paths.get(path + "/tmp" + currentDate + ".backup");

        File bcFile = new File(path + "/tmp/" + currentDate + ".backup");
        Files.copy(filePath, bcPath);
    }



    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        help();

        boolean isExit = false;
        while (!isExit) {
            try {
                System.out.print("> ");
                String userInput = scanner.nextLine();
                List<String> commandArgs = getArgs(userInput);
                if ((commandArgs.size() < 1) || (commandArgs.size() == 1 && !commandArgs.get(0).equals("help") && !commandArgs.get(0).equals("exit"))) throw new CommandArgsException("not enough Input arguments");


                switch (commandArgs.get(0)) {
                    case "ls" -> listDirectory(commandArgs.get(1));
                    case "ls_py" -> listPythonFiles(commandArgs.get(1));
                    case "is_dir" -> isDirectory(commandArgs.get(1));
                    case "define" -> define(commandArgs.get(1));
                    case "readmod" -> printPermissions(commandArgs.get(1));
                    case "setmod" -> setPermissions(commandArgs.get(1), commandArgs.get(2));
                    case "cat" -> printContent(commandArgs.get(1));
                    case "append" -> appendFooter(commandArgs.get(1));
                    case "bc" -> createBackup(commandArgs.get(1));
                    case "greplong" -> printLongestWord(commandArgs.get(1));
                    case "help" -> help();
                    case "exit" -> {
                        exit();
                        isExit = true;
                    }
                    default -> {
                        System.out.println("The command is not recognized");
                    }
                }

            } catch(Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
}